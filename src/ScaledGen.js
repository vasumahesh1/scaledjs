// The MIT License (MIT)

// Copyright (c) 2015 Vasu Mahesh (vasu.mahesh@[yahoo|hotmail|gmail].com)

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// 
// 

/**
 * Main Constructor for the Generator Object
 * @param {object}	settingsData	Configuring Settings of the Generator
 */
var ScaledGen = function(settingsData) {
	this.maxTries = 10;

	if (settingsData) {
		if (("debug" in settingsData) && settingsData["debug"] === true) {
			Commons.debug = true;
		}

		if (("logs" in settingsData)) {
			Commons.allowedLogs = settingsData["logs"];
		}

		if (("maxTries" in settingsData)) {
			this.maxTries = settingsData["maxTries"];
		}

		if (("onProgressUpdate" in settingsData)) {
			Commons.showProgressUpdate = settingsData["onProgressUpdate"];
		}


	}

	this.mainMap = new ScaledMap();
};

/**
 * Gets the Map Values (2D Array) for the User
 */
ScaledGen.prototype.GetMapValues = function() {
	return this.mainMap.mapValues;
};

/**
 * Sets the Map Size
 * @param {integer}	rowSize Size of the Row
 * @param {integer} columnSize Size of the Column
 */
ScaledGen.prototype.SetMapSize = function(rowSize, columnSize) {
	this.mainMap['rowSize'] = rowSize;
	this.mainMap['columnSize'] = columnSize;
};

/**
 * Adds a Scaled Terrain Object to a Map Instance
 * @param {object}	terrainData	Object containing information about the terrain
 */
ScaledGen.prototype.AddTerrain = function(terrainData) {
	this.mainMap.AddTerrain(terrainData);
};

/**
 * Assigns Starting Condition to a Particular Layer
 * @param {object}	conditionData Object containing information about the starting condition
 */
ScaledGen.prototype.AddStartingCondition = function(conditionData) {
	this.mainMap.AddStartingCondition(conditionData);
};

/**
 * Assigns a Validation Rule to a Particular Layer
 * @param {object}	ruleData Object containing information about the rule
 */
ScaledGen.prototype.AddValidationRule = function(ruleData) {
	this.mainMap.AddValidationRule(ruleData);
};


/**
 * Main Function to start the Map Generation Process
 * Process goes on until a valid map has been generated or the max tries have finished
 */
ScaledGen.prototype.GenerateMap = function() {
	var validStatus = false;
	var tries = 0;
	do {
		this.mainMap.GenerateMapValues();
		validStatus = this.mainMap.CheckRegularTerrainValidity();
		tries++;
	} while (validStatus === false && tries < this.maxTries);

	if (validStatus === false) {
		Commons.Error("Unable to Validate Map. Perhaps Conditions set are too Strict.");
	}
};

/**
 * Generates an HTML Representation of the 2D Matrix generated by ScaledJS
 */
ScaledGen.prototype.RenderMapValues = function(identifier) {
	var map_element = document.getElementById(identifier);
	map_element.innerHTML = "";
	var mapValues = this.mainMap.mapValues;
	var mapHtml = "";
	for (var rowKey in mapValues) {
		mapHtml += this.GenerateRow(mapValues[rowKey]);
	}
	map_element.innerHTML = mapHtml;
};


/**
 * Generates an HTML Row for the Map
 * @param {Array} rowValues	Contains an Array of Values
 */
ScaledGen.prototype.GenerateRow = function(rowValues) {
	var rowHtml = "<div class='row'>";
	for (var columnKey in rowValues) {
		rowHtml += this.GenerateCell(rowValues[columnKey]);
	}
	rowHtml += "</div>";
	return rowHtml;
};

/**
 * Generates an HTML Cell for the Map
 * @param {integer} cellValue Cell Value
 */
ScaledGen.prototype.GenerateCell = function(cellValue) {
	var responsibleTerrains = this.mainMap.GetLayersFromValue(cellValue);
	var terrainKey = "no-cell";
	for (var key in responsibleTerrains) {
		if (responsibleTerrains[key].IsRegularTerrain() === true) {
			terrainKey = responsibleTerrains[key].terrainKey;
			break;
		}
	}

	var html = "";
	html += "<div class='cell " + terrainKey + " ";
	html += "data-value='" + cellValue + "' ";
	html += "'>";
	html += "</div>";
	return html;
};